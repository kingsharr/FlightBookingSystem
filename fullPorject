import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
/**
 *
 * @author sharr
 * this class manages each flights data and booking + canceling
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

class Flight {

    private String flightCode; // flightID
    private String flightDate; //date to book flight
    private int availableSeats; // num of seats able to book
    private List<Ticket> bookedTickets; // stores confirmed tickets !!
    private Queue<Ticket> waitingList = new Queue<>();  // waiting list q
    private QueueStore queueStore = new QueueStore(waitingList);    // queue list for storage

    // constructor
    public Flight(String flightCode, String flightDate, int availableSeats) {
        this.flightCode = flightCode;
        this.flightDate = flightDate;
        this.availableSeats = availableSeats;
        this.bookedTickets = new ArrayList<>();
        this.queueStore = new QueueStore(waitingList);

    }
     public List<Ticket> getBookedTickets() {
        return bookedTickets;
    }

    // Add method to get waiting list
    
public List<Ticket> getWaitingList() {
    return waitingList.getQueue(); // Assuming waitingList is aÂ Queue<Ticket>
}
   private void saveConfirmedTicketToCSV(Ticket ticket) {
        try (FileWriter fileWriter = new FileWriter("ConfirmedTickets.csv", true)) {
            // Check if file is empty to add header
            File file = new File("ConfirmedTickets.csv");
            if (file.length() == 0) {
                fileWriter.append("TicketID,PassengerName,PassengerID,FlightCode,FlightDate\n");
            }
            
            // Append ticket details
            fileWriter.append(String.format("%s,%s,%s,%s,%s\n", 
                ticket.getTicketId(), 
                ticket.getPassenger().getName(), 
                ticket.getPassenger().getPassengerId(),
                this.flightCode,
                this.flightDate));
        } catch (IOException e) {
            System.out.println("Error saving confirmed ticket: " + e.getMessage());
        }
    }

    // getter for flight id
    public String getFlightCode() {
        return flightCode;
    }

    // getter for flight date
    public String getDate() {
        return flightDate;
    }

    // getter for flight seats
    public int getAvailableSeats() {
        return availableSeats;
    }

    // method to book ticket 
    public Ticket bookTicket(Ticket ticket) {
        if (availableSeats > 0) {
            bookedTickets.add(ticket);  //add passenger to confirmed list
            availableSeats--;   // reduce seat num
            ticket.setStatus(TicketStatus.CONFIRMED);

            // save to confirmed tickets CSV
            saveConfirmedTicketToCSV(ticket);

            // update to csv
            saveSeatsData(flightCode, availableSeats);

            return ticket;
        } else {
            ticket.setStatus(TicketStatus.WAITING);

            // no vacancy add passenger to waiting list
            queueStore.loadFromCSV("waitinglist.csv");
            queueStore.enqueueSave(ticket, "waitinglist.csv");

            return ticket;
        }
    }

        

//
    // update available seats info realtime
    public void saveSeatsData(String flightCode, int newAvailableSeats) {
        // temp list
        List<String> updatedLine = new ArrayList<>();

        try {
            // get existing data to check code
            List<String> lines = Files.readAllLines(Paths.get("FlightData.csv"));

            // in each line split for code part only
            for (String line : lines) {
                String[] parts = line.split(",");

                if (parts[0].equals(flightCode)) { //match !!
                    parts[2] = String.valueOf(newAvailableSeats);
                }

                updatedLine.add(String.join(",", parts));
            }

            // write back to csv
            Files.write(Paths.get("FlightData.csv"), updatedLine);
        } catch(IOException e) {
            System.out.println("Error saving new flight data !!");
        }
        
    }

    @Override
    public String toString() {
        return "Flight Code: " + flightCode + ", Date: " + flightDate + ", Available Seats: " + availableSeats;
    }

    
}

 class FlightSchedule {
    
    private String week;
    private HashMap<String, Flight> flights;    // use hashmap to store flight details

    public FlightSchedule(String week) {
        this.week = week;
        this.flights = new HashMap<>();
    }

    public String getWeek() {
        return week;
    }

    // add flight based on flight id from flight class
    public void addFlight(Flight flight) {
        flights.put(flight.getFlightCode(), flight);
    }

    // returns specified flight details ignoring casing
    public Flight getFlight(String flightId) {
        
        for (String key : flights.keySet()) {
            if (key.equalsIgnoreCase(flightId)) {
                return flights.get(key);  
            }
        }
        return null;  // not found
    }

   
    // display all flight sch for the week as list
    public List<Flight> listFlights()  {
    if (flights.isEmpty()) {
        System.out.println("No flights scheduled for this week.");
        return new ArrayList<>();  // return empty list 
    } else {

        // sort ascending and numerical
        List<Flight> sortFlight = new ArrayList<>(flights.values());
        Collections.sort(sortFlight, new Comparator<Flight>() {
            @Override
            public int compare(Flight f1, Flight f2) {  // check numerical
                int code1 = Integer.parseInt(f1.getFlightCode().split("-")[0].substring(2));
                int code2 = Integer.parseInt(f2.getFlightCode().split("-")[0].substring(2));
                return Integer.compare(code1, code2);
            }
        });


        System.out.println("Flights for the week: " + week);

        for (Flight flight : sortFlight) {
            System.out.println(flight);
        }
        return sortFlight;  // return generated flights
    }

    }
}




class FlightTicketSystem {

     private List<Flight> flights = new ArrayList<>();
    private HashMap<String, Ticket> allBookings = new HashMap<>(); // Storing all tickets by Ticket ID
    private HashMap<String, Passenger> registeredPassenger = new HashMap<>();

    public List<Flight> getFlights() {
        return this.flights;
    }

    // load flight data from csv
    public void loadFlightData(String filePath, boolean printData) {

        try {
            Scanner sc = new Scanner(new File(filePath));

            // skip header !!!
            if (sc.hasNextLine()) {
                sc.nextLine();
            }

            while (sc.hasNextLine()) {
                
                String line = sc.nextLine();

                // only print if true
                if (printData == true) {
                    System.out.println(line);
                }
                
                String[] data = line.split(",");   // split by comma

                if (data.length == 3) {
                    String flightId = data[0];
                    String flightDate = data[1];
                    int availableSeats  = Integer.parseInt(data[2]);
    
                    flights.add(new Flight(flightId, flightDate, availableSeats));
    
                }
                
            }
            sc.close();
        } catch (FileNotFoundException e) {
            System.out.println("File Not Found ");
            e.printStackTrace();
        }
    
        
    }
    

    // Optional method to check Confirmed Tickets CSV
    private void checkConfirmedTicketsCSV(String ticketId) {
        try (BufferedReader reader = new BufferedReader(new FileReader("ConfirmedTickets.csv"))) {
            String line;
            boolean found = false;
            
            // Skip header
            reader.readLine();
            
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(",");
                if (parts[0].trim().equals(ticketId)) {
                    System.out.println("\n===== Historical Ticket Record =====");
                    System.out.println("Ticket ID found in past confirmed tickets");
                    System.out.println("Passenger: " + parts[1]);
                    System.out.println("Flight Code: " + parts[3]);
                    System.out.println("Note: This ticket may have been processed previously");
                    System.out.println("===============================");
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                System.out.println("\nNo historical ticket records found.");
            }
        } catch (IOException e) {
            System.out.println("Error checking confirmed tickets CSV: " + e.getMessage());
        }
    }



    // search for flight by week
    public void searchFlights(String userInput) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        LocalDate inputDate = LocalDate.parse(userInput.trim(), formatter);  // ensure right format

        // find start week and end week by user input
        LocalDate startWeek = inputDate.with(DayOfWeek.MONDAY);
        LocalDate endWeek = startWeek.plusDays(6); // total 7 end sunday

        System.out.println("Searching for flights from " + startWeek + " to " + endWeek);

        // set found flights in a list
        List<String> flightsFound = new ArrayList<>();

        for (Flight flight : flights) {
            String flightDate = flight.getDate().trim();
            LocalDate fLocalDate = LocalDate.parse(flightDate, formatter);

            // debug check if can get flight code or not
            //System.out.println("\nFlight: " + flight.getFlightCode() + "ON " + fLocalDate);

            // check for the week in the range of user input datess ONLY
            if (!fLocalDate.isBefore(startWeek) && !fLocalDate.isAfter(endWeek)) {
                flightsFound.add("Flight ID: " + flight.getFlightCode() + ", Date: " + flight.getDate() + ", Available Seats: " + flight.getAvailableSeats());
            }

        }

        // display
        if (!flightsFound.isEmpty()) {
            System.out.println("Flights for the week of " + userInput);
            for (String flight : flightsFound) {
                System.out.println(flight);
            }
        } else {
            System.out.println("No flights available!! ");
        }


    }

    // book ticket for the user input flight id
   public void bookTicket(String flightId, String passengerName, String passengerId) {
        Flight flight = null;
        
      
        
        // Find the flight
        for (Flight userFlight : flights) {
            if (userFlight.getFlightCode().equals(flightId)) {
                flight = userFlight;
                break;
            }
        }
        
        // Not found flight
        if (flight == null) {
            System.out.println("No flight found with ID: " + flightId);
            return;
        }

        // Create passenger and ticket
        Passenger passenger = new Passenger(passengerName, passengerId);
        Ticket ticket = new Ticket(passenger, TicketStatus.WAITING, flight);
        Ticket bookedTicket = flight.bookTicket(ticket);

        // Store passenger and ticket
        registeredPassenger.put(passengerId, passenger);
        allBookings.put(bookedTicket.getTicketId(), bookedTicket);

        if (bookedTicket.getStatus() == TicketStatus.CONFIRMED) {
            System.out.println("Ticket booked successfully: " + bookedTicket);
        } else {
            System.out.println("No seats available. Added to Waiting List " + bookedTicket);
        }
    }

   

}
public class Main {

    // display selected flight
    public static Flight selectFlight(List<Flight> flights, String flightCode) {
        for (Flight flight : flights) {
            if (flight.getFlightCode().equalsIgnoreCase(flightCode)){
                return flight;
            }
        }
        return null;    // not found
    }

    public static void flightMenu() {
        System.out.println("\n~~\n1.  View All Flights ");
        System.out.println("2.  Search for Flights ");
        System.out.println("3.  Book Flight Ticket");
        System.out.println("4.  Cancel Ticket");
        System.out.println("5.  View Ticket Status");
         System.out.println("6.  Edit Ticket Information"); 
        System.out.println("7.  Exit ");
        System.out.println("Select an option: ");
    }

    public static void main(String[] args) {
        
        Scanner scanner = new Scanner(System.in);

        FlightTicketSystem ticketSystem = new FlightTicketSystem();
        TicketManager ticketManager = new TicketManager(ticketSystem);
        String weekStartDate = null;
        List<Flight> availableFlights = null;
        
        // start system until user select 6
        System.out.println("~~~~~~~~ Welcome To XYZ Flight Ticket System ~~~~~~~~");

        while (true) {

            flightMenu();

            int choice = scanner.nextInt();
            scanner.nextLine();

            switch (choice) {
                case 1:
                    // view csv all flights
                    System.out.println("FlightCode     Date  Available seats");
                    ticketSystem.loadFlightData("FlightData.csv", true);
                    break;

                case 2:     
                    // search for flight by week

                    // check if data loaded 
                    if (ticketSystem.getFlights().isEmpty()) {
                        ticketSystem.loadFlightData("FlightData.csv", false);
                    } 

                    // user input specific date of week to search
                    System.out.println("Enter date of the week (yyyy-MM-dd): ");
                    
                    // check date format accuracyy
                    while (true) {
                        weekStartDate = scanner.nextLine().trim();
                        try {
                            LocalDate.parse(weekStartDate, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
                            // search flight method
                            ticketSystem.searchFlights(weekStartDate);
                            break;
                        } catch (Exception e) {
                            System.out.println("Invalid date format!! Try again!!");
                        }
                    }

                    
                    break;
                
                case 3:     
                    // book ticket

                    // check if data loaded 
                    if (ticketSystem.getFlights().isEmpty()) {
                        ticketSystem.loadFlightData("FlightData.csv", false);
                    } 

                    // User selects a flight
                    System.out.println("\nEnter a flight code to book a ticket:");
                    String flightCode = scanner.nextLine();

                    // select the flight
                    Flight selectedFlight = selectFlight(ticketSystem.getFlights(), flightCode);

                    if (selectedFlight != null) {
                        // User provides passenger details
                        System.out.println("Enter your name: ");
                        String passengerName = scanner.nextLine();
                        System.out.println("Enter your Pasport number: ");
                        String passengerId = scanner.nextLine();

                        // check validation
                        if (passengerName.isEmpty() || passengerId.isEmpty()) {
                            System.out.println("Invalid Input \n Failed to Book Ticket");
                            
                        } else {
                            // pass to method
                            ticketSystem.bookTicket(flightCode, passengerName, passengerId);

                        }
                    } else {
                        System.out.println("Flight ID is invalid!");
                    }
                    
                    
                    break;

               case 4: // Cancel Ticket
    System.out.print("Enter Flight ID: ");
    String flightId = scanner.nextLine();
    System.out.print("Enter Passenger ID to cancel: ");
    String passengerId = scanner.nextLine();
    
    ticketManager.cancelTicket(flightId, passengerId);
    break;
                
   case 5: // View Ticket Status
    System.out.println("Enter Flight ID:");
    String flightIdToView = scanner.nextLine();
    System.out.println("Enter Passenger ID:");
    String passengerIdToView = scanner.nextLine();
    ticketManager.viewTicketStatus(flightIdToView, passengerIdToView);
    break;
            
           case 6: // Edit Ticket Information
    System.out.println("Enter Flight ID:");
    String flightIdToEdit = scanner.nextLine();
    System.out.println("Enter Passenger ID:");
    String passengerIdToEdit = scanner.nextLine();
    ticketManager.editTicket(flightIdToEdit, passengerIdToEdit, scanner);
    break;

                  

                case 7: 
                    //exit
                    System.out.println("Exiting system... \nThank you for using XYZ Flight Booking System");
                    scanner.close();
                    System.exit(0);
                    break;
                    
            
                default:
                    System.out.println("Invalid option. Please try again!! ");
                    break;
            }
        }

    }
}
class Passenger {
    
    private String name;
    private String PasportNum;

    // constructor
    public Passenger(String name, String PasportNum) {
        this.name = name;
        this.PasportNum = PasportNum;
    }

    //getters 
    public String getName() {
        return name;
    }

    public String getPassengerId() {
        return PasportNum;
    }

    //settters
    public void setName(String name) {
        this.name = name;
    }

    public void setPasportNum(String PasportNum) {
        this.PasportNum = PasportNum;
    }

    @Override
    public String toString() {
        return "Passenger Name: " + name + ", ID: " + PasportNum;
    }
}


class Queue<T> {
    
    private LinkedList<T> queue;

    public Queue() {
        this.queue = new LinkedList<>();
    }

    // enqueue
    public void enqueue(T item) {
        queue.addLast(item);
    }

    // dequeue
    public T dequeue() {
        if (!queue.isEmpty()) {
            return queue.removeFirst();
        }
        return null;
    }

    //check empty
    public boolean isEmpty() {
        return queue.isEmpty();
    }

    //return queue
    public LinkedList<T> getQueue() {
        return queue;
    }

    //return queue size
    public int size() {
        return queue.size();
    }

    // peek
    public T peek() {
        if (!queue.isEmpty()) {
            return queue.getFirst();
        }
        return null;
    }
}



class QueueStore {
    
    private Queue<Ticket> queue;

    public QueueStore(Queue<Ticket> queue) {
        this.queue = queue;
    }

    // enqueue n save to csv
     public void enqueueSave(Ticket ticket, String filepath) {
        queue.enqueue(ticket);
        saveToCSV(filepath);
    }

    // dequeueu n remove frm csv
    public Ticket dequeueRemove(String filepath) {
        Ticket ticket2 = queue.dequeue();
        if (ticket2 != null) {
            removeFromCSV(ticket2, filepath);
        }
        
        return ticket2;
        
    }

    // save queueu to csv file
    private void saveToCSV(String filepath) {
    try {
        File file = new File(filepath);
        boolean fileExists = file.exists() && file.length() > 0;

        try (FileWriter fileWriter = new FileWriter(filepath, false)) {
            // Add header if file is new or empty
            if (!fileExists) {
                fileWriter.append("TicketID,PassengerName,PassengerID,FlightCode,FlightDate\n");
            }

            for (Ticket ticket : queue.getQueue()) {
                fileWriter.append(ticket.getTicketId()).append(",")
                .append(ticket.getPassenger().getName()).append(",")
                .append(ticket.getPassenger().getPassengerId()).append(",")
                .append(ticket.getFlight().getFlightCode()).append(",")
                .append(ticket.getFlight().getDate()).append("\n");
            }
        }
        
    } catch (IOException e) {
        System.out.println("Error: " + e.getMessage());
    }
}

    // remove ticket from csv once if availble seats
    private void removeFromCSV(Ticket ticket, String filepath) {
    try {
        // Read all lines from the file
        List<String> lines = Files.readAllLines(Paths.get(filepath));
        
        // Create a list to store lines to keep
        List<String> updatedLines = new ArrayList<>();
        
        // Add header first
        updatedLines.add(lines.get(0));
        
        // Iterate through the lines, skipping the header
        boolean removed = false;
        for (int i = 1; i < lines.size(); i++) {
            String line = lines.get(i);
            String[] details = line.split(",");
            
            // Check if this line matches the ticket to remove
            if (!removed && 
                details[2].trim().equals(ticket.getPassenger().getPassengerId()) && 
                details[1].trim().equals(ticket.getPassenger().getName()) && 
                details[3].trim().equals(ticket.getFlight().getFlightCode())) {
                // Skip this line (effectively removing it)
                removed = true;
            } else {
                // Keep this line
                updatedLines.add(line);
            }
        }
        
        // Write the updated lines back to the file
        Files.write(Paths.get(filepath), updatedLines);
        
        if (removed) {
            System.out.println("Ticket removed from waiting list.");
        }
    } catch (IOException e) {
        System.out.println("Error removing ticket from CSV: " + e.getMessage());
    }
}

    // load csv waiting list
    public void loadFromCSV(String filepath) {
    try (BufferedReader reader = new BufferedReader(new FileReader(filepath))) {
        
        String line;
        boolean isFirstLine = true;

        while ((line = reader.readLine()) != null ) {
            // Skip header
            if (isFirstLine) {
                isFirstLine = false;
                continue;
            }

            String[] details = line.split(",");

            if (details.length == 5) {
                // Set a default status if parsing fails
                TicketStatus status = TicketStatus.WAITING;
                
                Ticket ticket = new Ticket(
                    new Passenger(details[1].trim(), details[2].trim()),
                    status, 
                    new Flight(details[3].trim(), "", 0));

                queue.enqueue(ticket);
            }
        }
        
    } catch (IOException e) {
        System.out.println("Error: " + e.getMessage());
    }
}
}
 class Ticket {
    
    private String ticketId;
    private static int ticketCount = 1000; // start count 1000
    private Passenger passenger;    // passenger obj
    private TicketStatus status;    // ticket status obj
    private Flight flight;          // flight obj

    // constructor
    public Ticket(Passenger passenger, TicketStatus status, Flight flight) {
        this.ticketId = "T" + (ticketCount++);  // simple id
        this.passenger = passenger;
        this.status = status;
        this.flight = flight;
    }
    

    //getters 
    public String getTicketId() {
        return ticketId;
    }

    public Passenger getPassenger() {
        return passenger;
    }

    public TicketStatus getStatus() {
        return status;
    }

    public Flight getFlight() {
        return flight;
    }

    //set status
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "\n\n===== Ticket Info =====" + "\nTicket ID: " + ticketId + " \nPassenger Name: " + passenger.getName() +
               "\nStatus: " + status + "\nFlight ID: " + flight.getFlightCode() + "\n================";
    }
}

    enum TicketStatus {
    CONFIRMED,
    WAITING
}
class TicketManager {
    private FlightTicketSystem ticketSystem;

    public TicketManager(FlightTicketSystem ticketSystem) {
        this.ticketSystem = ticketSystem;
    }
    public void cancelTicket(String flightId, String passengerId) {
    try {
        // First, check and remove from Confirmed Tickets CSV
        boolean removedFromConfirmed = cancelConfirmedTicket(flightId, passengerId);
        
        // If removed from confirmed, process waiting list
        if (removedFromConfirmed) {
            // Create a Queue to manage waiting list
            Queue<Ticket> waitingQueue = new Queue<>();
            QueueStore queueStore = new QueueStore(waitingQueue);
            
            // Load waiting list tickets from CSV
            queueStore.loadFromCSV("waitinglist.csv");
            
            // Find and remove the first waiting ticket for this flight
            Ticket firstWaitingTicket = findFirstWaitingTicketForFlight(waitingQueue, flightId);
            
            if (firstWaitingTicket != null) {
                // Remove the ticket from waiting list
                queueStore.dequeueRemove("waitinglist.csv");
                
                // Update flight available seats
                updateFlightAvailableSeats(firstWaitingTicket.getFlight().getFlightCode());
                
                // Save this ticket to confirmed tickets
                saveToConfirmedTickets(firstWaitingTicket);
                
                System.out.println("First waiting list ticket promoted to confirmed.");
            } else {
                // If no waiting list ticket, still update available seats
                updateFlightAvailableSeats(flightId);
            }
        } else {
            // If not in confirmed, check waiting list
            boolean removedFromWaiting = cancelWaitingTicket(flightId, passengerId);
            
            if (removedFromWaiting) {
                System.out.println("Ticket removed from waiting list.");
            } else {
                System.out.println("No ticket found for Passenger ID " + passengerId + " on Flight " + flightId);
            }
        }
    } catch (IOException e) {
        System.out.println("Error canceling ticket: " + e.getMessage());
    }
}

private void updateFlightAvailableSeats(String flightCode) throws IOException {
    List<String> lines = new ArrayList<>();
    boolean flightUpdated = false;

    try (BufferedReader reader = new BufferedReader(new FileReader("FlightData.csv"))) {
        // Read header
        String header = reader.readLine();
        lines.add(header);

        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(",");
            
            // Check if flight matches
            if (parts[0].equals(flightCode)) {
                // Increment available seats
                int currentSeats = Integer.parseInt(parts[2]);
                parts[2] = String.valueOf(currentSeats + 1);
                
                line = String.join(",", parts);
                flightUpdated = true;
            }
            
            lines.add(line);
        }
    }


    // If flight was found and updated, rewrite the entire file
     if (flightUpdated) {
        try (FileWriter writer = new FileWriter("FlightData.csv")) {
            for (String updatedLine : lines) {
                writer.write(updatedLine + "\n");
            }
        }
    }
}

private Ticket findFirstWaitingTicketForFlight(Queue<Ticket> waitingQueue, String flightId) {
    for (Ticket ticket : waitingQueue.getQueue()) {
        if (ticket.getFlight().getFlightCode().equals(flightId)) {
            return ticket;
        }
    }
    return null;
}

private void saveToConfirmedTickets(Ticket ticket) throws IOException {
    try (FileWriter writer = new FileWriter("ConfirmedTickets.csv", true)) {
        // Check if file is empty to add header
        File file = new File("ConfirmedTickets.csv");
        if (file.length() == 0) {
            writer.append("TicketID,PassengerName,PassengerID,FlightCode,FlightDate\n");
        }
        
        // Append ticket details
        writer.append(String.format("%s,%s,%s,%s,%s\n", 
            ticket.getTicketId(), 
            ticket.getPassenger().getName(), 
            ticket.getPassenger().getPassengerId(),
            ticket.getFlight().getFlightCode(),
            ticket.getFlight().getDate()));
    }
}

private boolean cancelConfirmedTicket(String flightId, String passengerId) throws IOException {
    List<String> updatedLines = new ArrayList<>();
    boolean ticketRemoved = false;
    String cancelledTicketLine = null;
    
    try (BufferedReader reader = new BufferedReader(new FileReader("ConfirmedTickets.csv"))) {
        // Read header
        updatedLines.add(reader.readLine());

        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(",");
            
            // Check if ticket matches flight and passenger
            if (parts[3].equals(flightId) && parts[2].equals(passengerId)) {
                ticketRemoved = true;
                cancelledTicketLine = line;
                
                System.out.println("Ticket canceled: " + line);
            } else {
                updatedLines.add(line);
            }
        }
    }

    // Rewrite the file if a ticket was removed
    if (ticketRemoved) {
        try (FileWriter writer = new FileWriter("ConfirmedTickets.csv")) {
            for (String updatedLine : updatedLines) {
                writer.write(updatedLine + "\n");
            }
        }
        
        // Save cancelled ticket to CancelledTickets.csv
        if (cancelledTicketLine != null) {
            saveCancelledTicket(cancelledTicketLine);
        }
    }

    return ticketRemoved;
}

private boolean cancelWaitingTicket(String flightId, String passengerId) throws IOException {
    List<String> updatedLines = new ArrayList<>();
    boolean ticketRemoved = false;
    String cancelledTicketLine = null;
    
    try (BufferedReader reader = new BufferedReader(new FileReader("waitinglist.csv"))) {
        // Read header
        updatedLines.add(reader.readLine());
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(",");
            
            // Check if ticket matches flight and passenger
            if (parts[3].equals(flightId) && parts[2].equals(passengerId)) {
                ticketRemoved = true;
                cancelledTicketLine = line;
                System.out.println("Ticket removed from waiting list: " + line);
            } else {
                updatedLines.add(line);
            }
        }
    }

    // Rewrite the file if a ticket was removed
    if (ticketRemoved) {
        try (FileWriter writer = new FileWriter("waitinglist.csv")) {
            for (String updatedLine : updatedLines) {
                writer.write(updatedLine + "\n");
            }
        }
        
        // Save cancelled ticket to CancelledTickets.csv
        if (cancelledTicketLine != null) {
            saveCancelledTicket(cancelledTicketLine);
        }
    }

    return ticketRemoved;
}

private void saveCancelledTicket(String ticketLine) throws IOException {
    try (FileWriter fileWriter = new FileWriter("CancelledTickets.csv", true)) {
        // Check if file is empty to add header
        File file = new File("CancelledTickets.csv");
        if (file.length() == 0) {
            fileWriter.append("TicketID,PassengerName,PassengerID,FlightCode,FlightDate,CancellationDate\n");
        }
        
        // Append ticket details with cancellation date
        String cancelledTicketEntry = ticketLine + "," + 
            LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd")) + "\n";
        fileWriter.append(cancelledTicketEntry);
    }
}

    public void editTicket(String flightId, String passengerId, Scanner scanner) {
    try {
        // Check Confirmed Tickets CSV first
        boolean ticketFoundAndEdited = editConfirmedTicket(flightId, passengerId, scanner);

        // If not found in Confirmed Tickets, try Waiting List
        if (!ticketFoundAndEdited) {
            editWaitingListTicket(flightId, passengerId, scanner);
        }
    } catch (IOException e) {
        System.out.println("Error editing ticket: " + e.getMessage());
    }
}

private boolean editConfirmedTicket(String flightId, String passengerId, Scanner scanner) throws IOException {
    List<String> lines = new ArrayList<>();
    boolean ticketFoundAndEdited = false;

    try (BufferedReader reader = new BufferedReader(new FileReader("ConfirmedTickets.csv"))) {
        // Read header
        String header = reader.readLine();
        lines.add(header);

        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(",");
            
            // Check if ticket matches flight and passenger ID
            if (parts[3].equals(flightId) && parts[2].equals(passengerId)) {
                // Ticket found, allow editing
                System.out.println("Current Passenger Name: " + parts[1]);
                System.out.println("Passenger ID: " + parts[2]);
                
                // Ask for new passenger name
                System.out.print("Enter new passenger name (press Enter to keep current): ");
                String newName = scanner.nextLine().trim();
                if (newName.isEmpty()) {
                    newName = parts[1];
                }
                 System.out.print("Enter new passenger ID (press Enter to keep current): ");
                String newPassengerId = scanner.nextLine().trim();
                if (newPassengerId.isEmpty()) {
                    newPassengerId = parts[2];
                }
                
                // Reconstruct the line with updated information
                String updatedLine = String.format("%s,%s,%s,%s,%s", 
                    parts[0], newName, newPassengerId, parts[3], parts[4]);
                
                lines.add(updatedLine);
                ticketFoundAndEdited = true;
                
                System.out.println("Ticket information updated successfully!");
            } else {
                // Write the original line
                lines.add(line);
            }
        }
    }

    // If ticket was found and edited, rewrite the entire file
    if (ticketFoundAndEdited) {
        try (FileWriter writer = new FileWriter("ConfirmedTickets.csv")) {
            for (String updatedLine : lines) {
                writer.write(updatedLine + "\n");
            }
        }
    }

    return ticketFoundAndEdited;
}

private void editWaitingListTicket(String flightId, String passengerId, Scanner scanner) throws IOException {
    List<String> lines = new ArrayList<>();
    boolean ticketFoundAndEdited = false;

    try (BufferedReader reader = new BufferedReader(new FileReader("waitinglist.csv"))) {
        // Read header
        String header = reader.readLine();
        lines.add(header);

        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(",");
            
            // Check if ticket matches flight and passenger ID
            if (parts[3].equals(flightId) && parts[2].equals(passengerId)) {
                // Ticket found, allow editing
                System.out.println("Current Passenger Name: " + parts[1]);
                System.out.println("Passenger ID: " + parts[2]);
                
                // Ask for new passenger name
                System.out.print("Enter new passenger name (press Enter to keep current): ");
                String newName = scanner.nextLine().trim();
                if (newName.isEmpty()) {
                    newName = parts[1];
                }
                 System.out.print("Enter new passenger ID (press Enter to keep current): ");
                String newPassengerId = scanner.nextLine().trim();
                if (newPassengerId.isEmpty()) {
                    newPassengerId = parts[2];
                }
                
                // Reconstruct the line with updated information
                String updatedLine = String.format("%s,%s,%s,%s,%s", 
                    parts[0], newName, newPassengerId, parts[3], parts[4]);
                
                lines.add(updatedLine);
                ticketFoundAndEdited = true;
                
                System.out.println("Ticket information updated successfully!");
            } else {
                // Write the original line
                lines.add(line);
            }
        }
    }

    // If ticket was found and edited, rewrite the entire file
    if (ticketFoundAndEdited) {
        try (FileWriter writer = new FileWriter("waitinglist.csv")) {
            for (String updatedLine : lines) {
                writer.write(updatedLine + "\n");
            }
        }
    } else {
        System.out.println("No ticket found for Flight ID: " + flightId + " and Passenger ID: " + passengerId);
    }
}

    // Method to view ticket status by checking CSV files
   public void viewTicketStatus(String flightId, String passengerId) {
        boolean ticketFound = false;
        
        // Check Confirmed Tickets CSV
        try (BufferedReader confirmedReader = new BufferedReader(new FileReader("ConfirmedTickets.csv"))) {
            String line;
            confirmedReader.readLine(); // Skip header
            
            while ((line = confirmedReader.readLine()) != null) {
                String[] parts = line.split(",");
                if (parts[3].equals(flightId) && parts[2].equals(passengerId)) {
                    System.out.println("Ticket Status: CONFIRMED");
                    System.out.println("Passenger Name: " + parts[1]);
                    System.out.println("Flight Code: " + parts[3]);
                    ticketFound = true;
                    break;
                }
            }
        } catch (IOException e) {
            System.out.println("Error reading Confirmed Tickets: " + e.getMessage());
        }

        // If not found in confirmed, check Waiting List CSV
        if (!ticketFound) {
            try (BufferedReader waitingReader = new BufferedReader(new FileReader("waitinglist.csv"))) {
                String line;
                waitingReader.readLine();
                
                while ((line = waitingReader.readLine()) != null) {
                    String[] parts = line.split(",");
                    if (parts[3].trim().equals(flightId) && parts[2].trim().equals(passengerId)) {
                        System.out.println("Ticket Status: WAITING");
                        System.out.println("Passenger Name: " + parts[1]);
                        System.out.println("Flight Code: " + parts[3]);
                        ticketFound = true;
                        break;
                    }
                }
            } catch (IOException e) {
                System.out.println("Error reading Waiting List: " + e.getMessage());
            }
        }

        // If ticket not found in either file
        if (!ticketFound) {
            System.out.println("No ticket found for Flight ID: " + flightId + " and Passenger ID: " + passengerId);
        }
    }
}
